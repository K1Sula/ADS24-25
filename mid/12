### Теорема мастера (Master Theorem)

**Теорема мастера** — это метод для анализа времени выполнения рекурсивных алгоритмов. Она используется для оценки асимптотической сложности решений рекуррентных отношений, которые часто возникают при работе с алгоритмами, например, с алгоритмами "разделяй и властвуй" (как в быстрой сортировке и сортировке слиянием).

Теорема мастера позволяет быстро определить сложность рекуррентного уравнения вида:

\[
T(n) = aT\left(\frac{n}{b}\right) + O(n^d)
\]

где:
- \(a \geq 1\) — количество рекурсивных вызовов,
- \(b > 1\) — на сколько уменьшается размер задачи на каждом шаге,
- \(n^d\) — сложность работы вне рекурсивных вызовов (например, разделение задачи, слияние результатов и т.д.).

### Три случая (условия теоремы мастера)

Есть три возможных сценария, которые нужно рассмотреть для анализа:

#### 1. **Случай 1**: \(a > b^d\)
   - Если \(a > b^d\), то основной вклад в сложность даёт количество рекурсивных вызовов.
   - **Решение**: 
     \[
     T(n) = O(n^{\log_b a})
     \]

#### 2. **Случай 2**: \(a = b^d\)
   - Если \(a = b^d\), то вклад в сложность дают как рекурсивные вызовы, так и работа на каждом уровне рекурсии.
   - **Решение**:
     \[
     T(n) = O(n^d \log n)
     \]

#### 3. **Случай 3**: \(a < b^d\)
   - Если \(a < b^d\), то основной вклад в сложность даёт работа, выполняемая вне рекурсивных вызовов (на каждом шаге задачи).
   - **Решение**:
     \[
     T(n) = O(n^d)
     \]

### Пример анализа рекуррентных уравнений

1. **Сортировка слиянием (Merge Sort)**:

Рекуррентное уравнение для сортировки слиянием выглядит так:
\[
T(n) = 2T\left(\frac{n}{2}\right) + O(n)
\]

Здесь:
- \(a = 2\) (две подзадачи),
- \(b = 2\) (размер подзадачи уменьшается в два раза),
- \(d = 1\) (работа вне рекурсии — это линейное слияние двух отсортированных списков).

Теперь вычисляем \(b^d = 2^1 = 2\).

Так как \(a = b^d\), попадаем во второй случай теоремы мастера, и время выполнения:
\[
T(n) = O(n \log n)
\]

2. **Быстрая сортировка (Quick Sort)** — худший случай:

Рекуррентное уравнение в худшем случае для быстрой сортировки:
\[
T(n) = T(n - 1) + O(n)
\]
Этот случай нельзя решать с помощью теоремы мастера напрямую, так как форма уравнения отличается. Однако, в среднем случае быстрая сортировка имеет рекуррентное уравнение аналогичное сортировке слиянием и также решается с помощью второго случая теоремы мастера, получая сложность \(O(n \log n)\).

3. **Рекурсия с меньшей долей задачи (например, бинарный поиск)**:

Рекуррентное уравнение для бинарного поиска:
\[
T(n) = T\left(\frac{n}{2}\right) + O(1)
\]

Здесь:
- \(a = 1\),
- \(b = 2\),
- \(d = 0\) (вне рекурсии работа постоянна: \(O(1)\)).

Теперь вычисляем \(b^d = 2^0 = 1\).

Так как \(a = b^d\), это опять второй случай, и сложность:
\[
T(n) = O(\log n)
\]

### Использование теоремы мастера

Теорема мастера — это мощный инструмент для анализа временной сложности рекурсивных алгоритмов. Однако она работает только для уравнений в виде \(T(n) = aT\left(\frac{n}{b}\right) + O(n^d)\). Если уравнение имеет другую форму (например, добавляются логарифмы или линейные множители), то нужно использовать другие методы анализа, такие как метод подстановки или деревья рекурсии.

Если тебе нужно разобрать конкретное уравнение или пример, дай знать!