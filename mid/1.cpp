/*
Время́ сложность (time complexity) — это мера, которая показывает, как изменяется время выполнения алгоритма 
в зависимости от размера входных данных. Она описывает, насколько быстро увеличивается количество шагов, которые требуется алгоритму, 
по мере увеличения объема входных данных.

Время сложность обычно выражается с помощью нотации O-большое (Big O), которая показывает верхнюю границу роста функции в худшем случае.

Вот несколько распространенных примеров временной сложности:

O(1) — Константная сложность: время выполнения не зависит от размера входных данных. Например, доступ к элементу массива по индексу.
O(n) — Линейная сложность: время выполнения алгоритма увеличивается пропорционально количеству входных данных. Например, простой проход по массиву.
O(log n) — Логарифмическая сложность: время выполнения растет медленно по сравнению с размером входных данных, например, бинарный поиск.
O(n²) — Квадратичная сложность: время выполнения растет пропорционально квадрату размера входных данных. Например, алгоритм сортировки пузырьком.
Понимание временной сложности важно для оценки эффективности алгоритмов и выбора наилучшего решения для конкретной задачи.




Чтобы рассчитать временную сложность алгоритма, необходимо проанализировать количество операций, которые выполняются в 
зависимости от размера входных данных. Этот анализ включает в себя шаги, которые нужно пройти в коде или алгоритме,
 и выражается в виде функции от размера входных данных n n. Вот основные шаги, как рассчитать временную сложность:

1. Выделите ключевые операции
Нужно определить операции, которые выполняются наиболее часто (например, арифметические операции, сравнения, присваивания и т.д.). 
Чаще всего временная сложность сосредоточена на циклах и рекурсиях.

2. Оцените сложность для каждой операции
Для каждого ключевого фрагмента программы определите, как часто он выполняется в зависимости от размера входных данных. Ниже рассмотрим несколько примеров.

Пример 1: Простая операция

cpp
Copy code
int a = 5;
int b = a + 10;
Это простая операция, и она выполняется 1 раз, независимо от размера данных. Временная сложность: O(1).

Пример 2: Линейный цикл

cpp
Copy code
for (int i = 0; i < n; i++) {
    // выполняемая операция
}
Здесь цикл выполняется n раз, где 
n
n — размер входных данных. Время выполнения будет зависеть от размера 
n
n, так что временная сложность: O(n).

Пример 3: Вложенные циклы

cpp
Copy code
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // выполняемая операция
    }
}
Во вложенных циклах внешний цикл выполняется 
n
n раз, и внутри каждого шага внешнего цикла внутренний цикл тоже выполняется 
n
n раз. В результате общее количество операций будет 
n
×
n
=
n
2
n×n=n 
2
 . Временная сложность: O(n²).

Пример 4: Логарифмический алгоритм

cpp
Copy code
while (n > 1) {
    n = n / 2;
}
Здесь цикл делит 
n
n на 2 на каждой итерации, так что количество итераций пропорционально
l
o
g
2
n
log 
2
​	
 n. Временная сложность: O(log n).

3. Игнорируйте константы и меньшие члены
Когда временная сложность выражается в виде 
O
−
большое
O−большое, константы и менее значительные члены отбрасываются, потому что они несущественны при увеличении размера данных. Например:

Если временная сложность алгоритма 
O
(
3
n
+
10
)
O(3n+10), то она упрощается до O(n).
Если временная сложность 
O
(
n
2
+
n
)
O(n 
2
 +n), то основным элементом будет 
n
2
n 
2
 , поэтому итоговая сложность: O(n²).
4. Анализ рекурсивных алгоритмов
Если алгоритм использует рекурсию, временная сложность может быть определена с помощью рекуррентных соотношений. Пример рекурсивной функции:

cpp
Copy code
int factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}
Эта функция вызывает саму себя 
n
n раз, поэтому временная сложность будет O(n).

Подведем итог:
Для того чтобы рассчитать временную сложность:

Оцениваем ключевые операции и их количество.
Анализируем циклы и рекурсию.
Составляем функцию от размера входных данных и упрощаем её, отбросив константы и меньшие члены.
Хочешь попробовать рассчитать сложность для какого-нибудь конкретного примера?
*/